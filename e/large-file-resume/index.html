<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head data-n-head="">
    <title data-n-head="true">Web 大文件上传浅析 | Star`s Blog</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="true" data-hid="description" name="description" content="a blog"><link data-n-head="true" rel="shortcut icon" href="/favicon.ico"><link rel="preload" href="/_nuxt/6baa0121b5cf70254d31.js" as="script"><link rel="preload" href="/_nuxt/9bb163b98addaa893413.js" as="script"><link rel="preload" href="/_nuxt/51ba38113466bee31c82.js" as="script"><link rel="preload" href="/_nuxt/9f2924d8c56d36a9ede1.js" as="script"><style data-vue-ssr-id="6ab1d7f0:0 2cb398ca:0 17cfdfa9:0 aab9a468:0 775b0850:0 435ed019:0">code[class*=language-],pre[class*=language-]{color:#ccc;background:0 0;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}body,html{margin:0;height:100%}a,a:link{text-decoration:none;color:inherit}p,ul{margin:0;padding:0}li{list-style:none}.md{line-height:1.8}.md h1,.md h2,.md h3,.md h4{margin-top:2em}.md a{color:#961723}.md a:hover{color:#999}.md blockquote{position:relative;margin:1em 0;padding:.5em 40px;background:#f2f2f2}.md blockquote:before{content:"";position:absolute;top:0;bottom:0;left:0;width:10px;background:#ddd}.md p{margin:24px 0}.md li>code,.md p>code{background:#f7f7f7;padding:5px;margin:0 5px;border-radius:5px;font-family:Menlo,Monaco,Courier New,monospace;word-break:break-all;color:#ca342e}.md code{font-size:14px}.md img{display:block;max-width:100%;margin:0 auto}.md ol li{list-style-type:decimal}.md ul li{list-style-type:disc}.md li{margin:4px 0}.md ul{list-style-type:disc;margin-top:1em;margin-bottom:1em;padding-left:40px}.md pre{border-radius:5px}.poem-md p{margin:15px 0}.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#fff;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}html{font-family:Helvetica Neue,Helvetica,Arial,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;color:#333}.header[data-v-04fba17a]{text-align:center}.header .header-img[data-v-04fba17a]{margin-top:22px;width:40px}.title[data-v-04fba17a]{max-width:100%;width:600px;margin:100px auto 120px}.title .title-h1[data-v-04fba17a]{font-size:32px;text-align:center;font-weight:400;margin:0}.title .title-date[data-v-04fba17a]{display:flex;align-items:center;justify-content:flex-end;font-size:16px;margin-top:10px;color:#666}.title .title-date-logo[data-v-04fba17a]{margin-right:5px}.body[data-v-04fba17a]{max-width:90%;width:800px;margin:auto;text-align:left;font-size:16px;padding-bottom:100px}.header[data-v-376b395e]{flex:none;height:60px;line-height:60px;border-bottom:1px solid #eee}.header-content[data-v-376b395e]{display:flex;align-items:center;margin:0 auto;max-width:80%;width:650px}.header-text[data-v-376b395e]{position:relative;font-size:20px;display:inline-block;height:100%;font-weight:400;margin:0 0 0 5px}.header-logo[data-v-376b395e]{width:35px;margin-right:5px}.header-nav[data-v-376b395e]{font-size:20px;padding:0;margin:0 0 0 50px}.header-nav-item[data-v-376b395e]{list-style:none}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><div class="article" data-v-04fba17a><header class="header" data-v-376b395e data-v-04fba17a><nav class="header-content" data-v-376b395e><a href="/" style="display:flex;align-items:center" data-v-376b395e><img src="/_nuxt/img/1c65b4e.png" alt class="header-logo" data-v-376b395e> <h1 class="header-text" data-v-376b395e>Star`s blog</h1></a> <ul class="header-nav" data-v-376b395e><li class="header-nav-item" data-v-376b395e><a href="/poem" style="position:relative" data-v-376b395e>
          Poems
        </a></li></ul></nav></header> <section class="title" data-v-04fba17a><h1 class="title-h1" data-v-04fba17a>Web 大文件上传浅析</h1> <p class="title-date" data-v-04fba17a><span data-v-04fba17a>2019-09-11</span></p></section> <section class="body md" data-v-04fba17a><h2>普通方式上传大文件的痛点</h2>
<p>上传大文件耗时比较久，普通的ajax、表单文件经常会遇到网络不稳定，不小心关掉浏览器等情况，再次上传时用户只能从头开始上传。如果有些需要上传几分钟甚至几小时的超大文件，用户将难以成功上传。第二点是后端一般都会有一些上传单个文件的大小限制，经典的例如 nginx 的 <code>client_max_body_size</code>，要上传大文件的话只能把这些值设置的很大，会带来一定的安全隐患</p>
<h2>解决思路</h2>
<p>在前端场景下，一些耗费性能的 js 任务可以使用 Event Loop 分片成子任务执行的方式解决，从而避免造成渲染阻塞。要上传大文件，可以采用相似的思路，把大文件拆分成数个小文件依次上传，后端把上传过来的这些小文件（<code>chunk</code>）按序拼接即可还原为源文件，这就引入了几个问题：</p>
<ol>
<li>如何将大文件拆分成 chunk</li>
<li>如何保证 chunk 的顺序</li>
<li>如何知道哪些 chunk 属于哪个源文件</li>
</ol>
<h3>文件拆分</h3>
<p>利用 HTML5 的 Blob.slice API 可以实现文件拆分，文件对象 File 是 Blob 的子类，继承了 Blob 类的所有方法，该方法兼容IE10+的现代浏览器</p>
<p>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice</a></p>
<p>兼容性：<a href="https://caniuse.com/#search=slice">https://caniuse.com/#search=slice</a></p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> chunk <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>startByte<span class="token punctuation">,</span> endByte<span class="token punctuation">,</span> file<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>假设我们设置 chunk 的最大大小为 1MB，要上传一个 100.5 MB 的大文件就可以按字节顺序把文件拆分成 101 个 chunk，并记录每个 chunk 的序号，比如第 10 个 chunk 的序号就是 10，0 - 100 序号的 chunk 大小都为 1MB，101 序号的 chunk 大小为 0.5 MB。通过 101 个 ajax post 请求上传每个 chunk，并将 chunk 的序号作为请求参数。后端每收到一个 chunk，就检查该 chunk 的序号是否是上一个 chunk 的序号 + 1，如果是则把该 chunk 拼接到当前文件中，如果不是则继续监听请求。</p>
<h3>文件 ID</h3>
<p>到目前为止，后端还不知道当前 chunk 是属于哪一个源文件的，一旦有多个文件上传的请求就会出现混乱。因此需要给每个源文件定义一个文件 ID，作为 chunk 的请求参数传给后端。生成文件 ID 一个比较好的方案是 <code>md5(fileSize + fileName + userid)</code>，userid 可确保不同用户上传同名的文件不会混淆。</p>
<h2>断点续传</h2>
<p>有了文件分片，就可以实现断点续传。断点续传的意思就是传文件时出于各种原因中断传输，下次传相同的文件还可以从上次中断的地方继续传输，而不需要从头开始上传。实现方案是在每次上传 chunk 之前先发一个查询请求，查询准备上传的这个 chunk 的文件 id 和序号是否在后端的上传缓存中已存在，如果后端返回已存在，则跳过该 chunk 的 post 上传请求，进行下一个 chunk 的查询，依次如此。当然，当文件完全上传完毕后后端需要清除该文件的所有上传缓存。</p>
<h2>Resumable.js</h2>
<p>Resumable.js 是一个实现了大文件上传的很方便的库，支持断点续传、获取上传进度</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">import</span> Resumable <span class="token keyword">from</span> <span class="token string">'resumable.js'</span>

<span class="token keyword">function</span> <span class="token function">uploadFile</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resumable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        target<span class="token punctuation">:</span> url<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    r<span class="token punctuation">.</span><span class="token function">addFile</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    r<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"fileAdded"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>file<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
        r<span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><a href="https://github.com/23/resumable.js">https://github.com/23/resumable.js</a></p>
</section></div></div></div></div><script>window.__NUXT__={layout:"default",data:[{data:{name:"large-file-resume",title:"Web 大文件上传浅析",modified_date:"2019-09-11",document:'<h2>普通方式上传大文件的痛点</h2>\n<p>上传大文件耗时比较久，普通的ajax、表单文件经常会遇到网络不稳定，不小心关掉浏览器等情况，再次上传时用户只能从头开始上传。如果有些需要上传几分钟甚至几小时的超大文件，用户将难以成功上传。第二点是后端一般都会有一些上传单个文件的大小限制，经典的例如 nginx 的 <code>client_max_body_size</code>，要上传大文件的话只能把这些值设置的很大，会带来一定的安全隐患</p>\n<h2>解决思路</h2>\n<p>在前端场景下，一些耗费性能的 js 任务可以使用 Event Loop 分片成子任务执行的方式解决，从而避免造成渲染阻塞。要上传大文件，可以采用相似的思路，把大文件拆分成数个小文件依次上传，后端把上传过来的这些小文件（<code>chunk</code>）按序拼接即可还原为源文件，这就引入了几个问题：</p>\n<ol>\n<li>如何将大文件拆分成 chunk</li>\n<li>如何保证 chunk 的顺序</li>\n<li>如何知道哪些 chunk 属于哪个源文件</li>\n</ol>\n<h3>文件拆分</h3>\n<p>利用 HTML5 的 Blob.slice API 可以实现文件拆分，文件对象 File 是 Blob 的子类，继承了 Blob 类的所有方法，该方法兼容IE10+的现代浏览器</p>\n<p>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice</a></p>\n<p>兼容性：<a href="https://caniuse.com/#search=slice">https://caniuse.com/#search=slice</a></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> chunk <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>startByte<span class="token punctuation">,</span> endByte<span class="token punctuation">,</span> file<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<p>假设我们设置 chunk 的最大大小为 1MB，要上传一个 100.5 MB 的大文件就可以按字节顺序把文件拆分成 101 个 chunk，并记录每个 chunk 的序号，比如第 10 个 chunk 的序号就是 10，0 - 100 序号的 chunk 大小都为 1MB，101 序号的 chunk 大小为 0.5 MB。通过 101 个 ajax post 请求上传每个 chunk，并将 chunk 的序号作为请求参数。后端每收到一个 chunk，就检查该 chunk 的序号是否是上一个 chunk 的序号 + 1，如果是则把该 chunk 拼接到当前文件中，如果不是则继续监听请求。</p>\n<h3>文件 ID</h3>\n<p>到目前为止，后端还不知道当前 chunk 是属于哪一个源文件的，一旦有多个文件上传的请求就会出现混乱。因此需要给每个源文件定义一个文件 ID，作为 chunk 的请求参数传给后端。生成文件 ID 一个比较好的方案是 <code>md5(fileSize + fileName + userid)</code>，userid 可确保不同用户上传同名的文件不会混淆。</p>\n<h2>断点续传</h2>\n<p>有了文件分片，就可以实现断点续传。断点续传的意思就是传文件时出于各种原因中断传输，下次传相同的文件还可以从上次中断的地方继续传输，而不需要从头开始上传。实现方案是在每次上传 chunk 之前先发一个查询请求，查询准备上传的这个 chunk 的文件 id 和序号是否在后端的上传缓存中已存在，如果后端返回已存在，则跳过该 chunk 的 post 上传请求，进行下一个 chunk 的查询，依次如此。当然，当文件完全上传完毕后后端需要清除该文件的所有上传缓存。</p>\n<h2>Resumable.js</h2>\n<p>Resumable.js 是一个实现了大文件上传的很方便的库，支持断点续传、获取上传进度</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">import</span> Resumable <span class="token keyword">from</span> <span class="token string">\'resumable.js\'</span>\n\n<span class="token keyword">function</span> <span class="token function">uploadFile</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resumable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        target<span class="token punctuation">:</span> url<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    r<span class="token punctuation">.</span><span class="token function">addFile</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    r<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"fileAdded"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>file<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        r<span class="token punctuation">.</span><span class="token function">upload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><a href="https://github.com/23/resumable.js">https://github.com/23/resumable.js</a></p>\n'}}],error:null,serverRendered:!0}</script><script src="/_nuxt/6baa0121b5cf70254d31.js" defer></script><script src="/_nuxt/9f2924d8c56d36a9ede1.js" defer></script><script src="/_nuxt/9bb163b98addaa893413.js" defer></script><script src="/_nuxt/51ba38113466bee31c82.js" defer></script>
    <script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?cd5b00c3422b216c98d26314b40e0ba8";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>
  </body>
</html>
